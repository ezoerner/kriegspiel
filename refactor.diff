diff --git a/app/Main.hs b/app/Main.hs
index 175fae4..b4e7bcb 100644
--- a/app/Main.hs
+++ b/app/Main.hs
@@ -20,11 +20,18 @@ import qualified Helm.Mouse                    as Mouse
 import qualified Helm.Sub                      as Sub
 import qualified Helm.Window                   as Window
 
-import           BoardView
 import           Model
+import           View
+import           Controller
 import           Options
 import           ChessUtils
 
+data App = App
+    { model :: !Model
+    , view :: !View
+    , options :: !Options
+    }
+
 data Action = DoNothing
             | ResizeWindow (V2 Int)
             | RotateBoard
@@ -42,17 +49,16 @@ backgroundColor = rgb (fromRational 252 / 255)
 background :: V2 Double -> Form e
 background v2 = move (v2 / 2) $ filled backgroundColor $ rect v2
 
-initialWindowDims :: V2 Int
-initialWindowDims = V2 1000 640
 
-initial :: Options -> (Model, Cmd SDLEngine Action)
-initial options = (initialModel options initialWindowDims, Cmd.none)
+initial :: Options -> (App, Cmd SDLEngine Action)
+initial options = (App initialModel initialView options, Cmd.none)
 
-update :: Model -> Action -> (Model, Cmd SDLEngine Action)
-update model (ResizeWindow windowSize) = (resize model windowSize, Cmd.none)
-update model@Model { playerState = Playing } RotateBoard =
-    (rotateBoard model, Cmd.none)
-update model@Model { playerState = Playing } HotSeatNext = (model, Cmd.none)
+update :: App -> Action -> (App, Cmd SDLEngine Action)
+update app{view} (ResizeWindow windowSize) =
+    (app {view = resizeView view windowSize}, Cmd.none)
+update app{view, model = Model{playerState = Playing}} RotateBoard =
+    (app {view = rotateBoard view}, Cmd.none)
+update app{model = Model { playerState = Playing }} HotSeatNext = (model, Cmd.none)
 update model@Model { playerState = HotSeatWait } HotSeatNext =
     (model { playerState = HotSeatBlank }, Cmd.none)
 update model@Model { playerState = HotSeatBlank } HotSeatNext =
diff --git a/src/BoardView.hs b/src/BoardView.hs
deleted file mode 100644
index 3ef012c..0000000
--- a/src/BoardView.hs
+++ /dev/null
@@ -1,352 +0,0 @@
-{-# LANGUAGE NamedFieldPuns #-}
-
-module BoardView where
-
-import           Chess
-import           Control.Applicative            ( pure )
-import           Control.Monad                  ( guard )
-import           Data.Array                    as A
-import           Data.Char                      ( ord
-                                                , chr
-                                                , toLower
-                                                )
-import           Data.List                      ( map
-                                                , sortOn
-                                                , foldl'
-                                                )
-import qualified Data.Map.Strict               as M
-import           Data.Maybe                     ( isJust
-                                                , fromJust
-                                                )
-import           Data.Maybe.HT                  ( toMaybe )
-import           Helm
-import qualified Helm.Color                    as HelmColor
-import           Helm.Engine                    ( Engine )
-import           Helm.Engine.SDL                ( SDLEngine )
-import qualified Helm.Graphics2D               as HGfx
-import           Helm.Graphics2D.Text
-import           Linear.V2                      ( V2(V2) )
-
-import           ChessUtils
-import           Options
-
--- for this game a bounding box is always square
-data BoundingSquare = BSquare
-    { width :: !Double
-    , topLeft :: !(V2 Double)
-    } deriving (Show)
-
-data BoardView = BoardView
-    { bbox :: !BoundingSquare
-    , orient :: !Color
-    , coordsInMotion :: !(Maybe Coordinates)
-    }
-    deriving (Show)
-
-data PlayerState =
-    Playing |
-    HotSeatWait |
-    HotSeatBlank |
-    PromotionPrompt Coordinates Coordinates
-  deriving (Show, Eq)
-
-initialBoardView :: V2 Int -> BoardView
-initialBoardView windowDims = BoardView
-    { bbox           = calcBoardBBox windowDims
-    , orient         = White
-    , coordsInMotion = Nothing
-    }
-
-border :: Num a => V2 a
-border = V2 100 100
-
-calcBoardBBox :: (Integral a, Ord a) => V2 a -> BoundingSquare
-calcBoardBBox windowSize =
-    let constrainSquare (V2 x y) = x `min` y
-        calcBoardSize = constrainSquare . subtract (2 * border)
-    in  BSquare
-            { width   = fromIntegral $ calcBoardSize windowSize
-            , topLeft = border
-            }
-
-findPositionWithPiece
-    :: Board -> BoardView -> V2 Double -> Color -> Maybe Coordinates
-findPositionWithPiece bord BoardView { bbox, orient } point playerTurn =
-    let maybeCoords = pointToCoords bbox point orient
-    in  maybeCoords >>= \testCoords ->
-            bord `pieceAt` printCoordinate testCoords >>= \(Piece clr _) ->
-                guard (clr == playerTurn) >> return testCoords
-
-pointToCoords :: BoundingSquare -> V2 Double -> Color -> Maybe Coordinates
-pointToCoords bbox (V2 x y) playerOrient =
-    let ssize = squareSize bbox
-        tryCoords White = (floor (y / ssize), floor (x / ssize))
-        tryCoords Black = (7 - floor (y / ssize), floor (x / ssize))
-        thisTryCoords = tryCoords playerOrient
-    in  isInsideBoard thisTryCoords `toMaybe` thisTryCoords
-
-toBoardLocal :: V2 Double -> BoundingSquare -> V2 Double
-toBoardLocal globalV2 bbox = globalV2 - topLeft bbox
-
-sideBarTexts
-    :: HelmColor.Color -- ^ the text color
-    -> MoveAttempt
-    -> GameState
-    -> PlayerState
-    -> [Text]
-sideBarTexts helmColor moveAttempt gameState playerState =
-    hotSeatTexts helmColor playerState (currentPlayer gameState)
-        ++ checkText helmColor gameState
-        ++ moveAttemptText helmColor moveAttempt
-        ++ promptPromoteText helmColor playerState
-
-hotSeatTexts :: HelmColor.Color -> PlayerState -> Color -> [Text]
-hotSeatTexts helmColor playerState currPlayer =
-    let prompt HotSeatWait =
-            ["Type <Space> to blank screen", "for " ++ show currPlayer]
-        prompt HotSeatBlank =
-            ["Type <Space> to start turn", "for " ++ show currPlayer]
-        prompt _ = []
-    in  height 20 . color helmColor . toText <$> prompt playerState
-
-promptPromoteText :: HelmColor.Color -> PlayerState -> [Text]
-promptPromoteText helmColor playerState =
-    let showPlayerState (PromotionPrompt _ _) =
-            [ "Promote Pawn:"
-            , "Type Q for Queen"
-            , "B for Bishop"
-            , "R for Rook"
-            , "N for Knight"
-            ]
-        showPlayerState _ = []
-    in  height 20 . color helmColor . toText <$> showPlayerState playerState
-
-checkText :: HelmColor.Color -> GameState -> [Text]
-checkText helmColor gameState =
-    let showCheck LongDiagonal  = "Check on long diagonal"
-        showCheck ShortDiagonal = "Check on short diagonal"
-        showCheck KnightCheck   = "Check from a Knight"
-        showCheck ckType        = show ckType ++ " check"
-    in  height 30
-        .   color helmColor
-        .   toText
-        .   showCheck
-        <$> findChecks gameState
-
-moveAttemptText :: HelmColor.Color -> MoveAttempt -> [Text]
-moveAttemptText helmColor moveAttempt =
-    let showLastMoveAttempt Successful = []
-        showLastMoveAttempt (Illegal (Piece _ pieceType) from (Just to)) =
-            [ "Move not legal: "
-            , show pieceType ++ " " ++ printMove from to Nothing
-            ]
-        showLastMoveAttempt (Illegal (Piece _ pieceType) from Nothing) =
-            [ "Not Allowed to move"
-            , show pieceType
-            , "  from " ++ printCoordinate from ++ " to off the board"
-            ]
-    in  height 30 . color helmColor . toText <$> showLastMoveAttempt moveAttempt
-
-toMoveText :: HelmColor.Color -> GameState -> Text
-toMoveText helmColor gameState =
-    let currPlayer = currentPlayer gameState
-        showToMove = case maybeGameOver gameState of
-            Nothing       -> " To Move: " ++ show currPlayer
-            Just gameOver -> show gameOver
-    in  height 30 $ color helmColor $ toText showToMove
-
-textOverlay
-    :: HelmColor.Color
-    -> BoardView
-    -> GameState
-    -> MoveAttempt
-    -> PlayerState
-    -> HGfx.Form SDLEngine
-textOverlay helmColor BoardView { bbox = BSquare { width, topLeft = (V2 left top) } } gameState moveAttempt playerState
-    = let
-          topX     = width / 2 + left
-          topY     = top / 2
-          sidebarX = width + left + 175
-          sidebarY = top + 15
-          topForm  = HGfx.move (V2 topX topY) $ HGfx.text $ toMoveText
-              helmColor
-              gameState
-
-          sbarTexts = sideBarTexts helmColor moveAttempt gameState playerState
-
-          calcOffsets :: [V2 Double] -> Text -> [V2 Double]
-          calcOffsets offs@(V2 x y : _) txt = V2 x (y + textHeight txt) : offs
-          calcOffsets []                _   = []
-
-          offsets :: [V2 Double]
-          offsets = reverse $ foldl' calcOffsets [pure 0] sbarTexts
-
-          toForm :: V2 Double -> Text -> HGfx.Form SDLEngine
-          toForm offset txt = HGfx.move offset $ HGfx.text txt
-
-          sidebarOffsetForm :: V2 Double -> Text -> HGfx.Form SDLEngine
-          sidebarOffsetForm (V2 x y) =
-              toForm (V2 (sidebarX + x) (sidebarY + y))
-      in
-          case sbarTexts of
-              [] -> topForm
-              [firstTxt] ->
-                  HGfx.group [topForm, toForm (V2 sidebarX sidebarY) firstTxt]
-              firstTxt : txts -> HGfx.group
-                  ( topForm
-                  : toForm (V2 sidebarX sidebarY) firstTxt
-                  : (uncurry sidebarOffsetForm <$> zip (tail offsets) txts)
-                  )
-
-boardForm
-    :: Engine e
-    => Image e
-    -> Image e
-    -> BoardView
-    -> [Coordinates]
-    -> HGfx.Form e
-boardForm lightSquare darkSquare BoardView { bbox = bbox@BSquare { width }, orient } pawnTries
-    = let ssize     = squareSize bbox
-          imageDims = V2 ssize ssize
-          pawnTryForm =
-            -- TODO attempt to vertically center text form inside group
-            -- doesn't work, bug in Helm?
-              HGfx.move (V2 0 ssize / 2)
-                  $ HGfx.text
-                  $ height 12
-                  $ color (HelmColor.rgb 1 1 1)
-                  $ bold
-                  $ toText "pawn try"
-          sqTypes = squareTypes pawnTries
-          sqForm Light = HGfx.image imageDims lightSquare
-          sqForm Dark  = HGfx.image imageDims darkSquare
-          buildForm (sqColor, False) = sqForm sqColor
-          buildForm (sqColor, True ) = HGfx.group [sqForm sqColor, pawnTryForm]
-          mkSquareForm coords = buildForm (sqTypes M.! coords)
-          mkRankLabel y =
-              HGfx.text
-                  $ height 15
-                  $ color (HelmColor.rgb (33 / 255) (118 / 255) $ 199 / 255)
-                  $ toText
-                  $ show
-                  $ if orient == White then 8 - y else y + 1
-          mkFileLabel x =
-              HGfx.text
-                  $ height 15
-                  $ color (HelmColor.rgb (33 / 255) (118 / 255) $ 199 / 255)
-                  $ toText [chr $ ord 'a' + x]
-      in  HGfx.toForm
-          $  HGfx.collage
-          $  [ HGfx.move (V2 hOff vOff) $ mkRankLabel (floor y :: Integer)
-             | y <- [0 .. 7]
-             , let vOff = y * ssize + (ssize / 2)
-             , let hOff = -10
-             ]
-          ++ [ HGfx.move (V2 hOff vOff) $ mkFileLabel $ floor x
-             | x <- [0 .. 7]
-             , let hOff = x * ssize + (ssize / 2)
-             , let vOff = width + 20
-             ]
-          ++ [ HGfx.move offset $ mkSquareForm coords
-             | file <- [0 .. 7]
-             , rank <- [0 .. 7]
-             , let coords = (rank, file)
-             , let offset = toOffset coords orient ssize
-             ]
-
-data SquareColor = Light | Dark
-        deriving (Show, Eq)
-type SquareType = (SquareColor, Bool) -- ^ bool is hasPawnTry
-
-squareTypes
-    :: [Coordinates]                -- ^ pawnTries
-    -> M.Map Coordinates SquareType -- ^ square types
-squareTypes pawnTries = M.fromList
-    [ (coord, squareType)
-    | rank <- [0 .. 7]
-    , file <- [0 .. 7]
-    , let coord       = (rank, file)
-    , let hasPawnTry  = coord `elem` pawnTries
-    , let squareColor = if (rank + file) `mod` 2 == 0 then Light else Dark
-    , let squareType = (squareColor, hasPawnTry)
-    ]
-
-piecesForm
-    :: Engine e
-    => PlayerState
-    -> GameState
-    -> Options
-    -> BoardView
-    -> M.Map String (Image e)
-    -> V2 Int
-    -> HGfx.Form e
-piecesForm playerState gameState Options { gameVariant } BoardView { bbox, orient, coordsInMotion } assets mousePos
-    = let
-          showColor clr = toLower (head $ show clr)
-          showPieceType pieceType = toLower <$> show pieceType
-          pieceName (Piece clr pieceType) =
-              showColor clr : "_" ++ showPieceType pieceType
-          chooseImage piece = assets M.! pieceName piece
-          ssize     = squareSize bbox
-          imageDims = pure ssize
-          mkForm piece = HGfx.image imageDims $ chooseImage piece
-
-          -- sort pieces so moving or promoting piece is on top
-          sortF :: PlayerState -> Coordinates -> Bool
-          sortF (PromotionPrompt _ toCoords) thisCoords =
-              (do
-                      p <- coordsInMotion
-                      return $ p == thisCoords || toCoords == thisCoords
-                  )
-                  == Just True
-          sortF _ thisCoords = Just thisCoords == coordsInMotion
-
-          pieceImage coords piece
-              | (PromotionPrompt fromCoords toCoords) <- playerState
-              , coords == fromCoords
-              = HGfx.move (toOffset toCoords orient ssize) $ mkForm piece
-              | coordsInMotion == Just coords
-              = HGfx.move
-                      ( toBoardLocal (fromIntegral <$> mousePos) bbox
-                      - imageDims
-                      / 2
-                      )
-                  $ mkForm piece
-              | otherwise
-              = HGfx.move (toOffset coords orient ssize) $ mkForm piece
-
-          pieces
-              = [ (coords, piece)
-                | (coords, square) <- assocs $ board gameState
-                , let maybePiece = squareToMaybe square
-                , isJust maybePiece
-                , let piece@(Piece clr _) = fromJust maybePiece
-                , case (isGameOver gameState, playerState, gameVariant, clr) of
-                    (True, _           , _    , _) -> True
-                    (_   , HotSeatBlank, _    , _) -> False
-                    (_   , _           , Chess, _) -> True
-                    (_, HotSeatWait, Kriegspiel, White) ->
-                        currentPlayer gameState == Black
-                    (_, HotSeatWait, Kriegspiel, Black) ->
-                        currentPlayer gameState == White
-                    (_, _, Kriegspiel, _) -> currentPlayer gameState == clr
-                ]
-          sortedPieces = sortOn (sortF playerState . fst) pieces
-          imageCollage = HGfx.collage $ map (uncurry pieceImage) sortedPieces
-      in
-          HGfx.toForm imageCollage
-
--- Private functions
-
-squareSize :: BoundingSquare -> Double
-squareSize bbox = width bbox / 8
-
-toOffset
-    :: Coordinates
-    -> Color -- ^ orientation of the board
-    -> Double -- ^ square size
-    -> V2 Double
-toOffset (rank, file) White ssize =
-    (fromIntegral <$> V2 file rank) * pure ssize
-toOffset (rank, file) Black ssize =
-    (fromIntegral <$> V2 file (7 - rank)) * pure ssize
diff --git a/src/Controller.hs b/src/Controller.hs
new file mode 100644
index 0000000..29f0b2d
--- /dev/null
+++ b/src/Controller.hs
@@ -0,0 +1,58 @@
+module Controller where
+
+import View
+import Model
+
+findPositionWithPiece :: Board -> View -> V2 Double -> Color -> Maybe Coordinates
+findPositionWithPiece bord View { bbox, orient } point playerTurn =
+  let maybeCoords = pointToCoords bbox point orient
+  in  maybeCoords >>= \testCoords ->
+        bord `pieceAt` printCoordinate testCoords >>= \(Piece clr _) ->
+          guard (clr == playerTurn) >> return testCoords
+
+startDragPiece :: Model -> V2 Int -> Model
+startDragPiece model@Model {view = view@View { bbox }, gameState } globalPoint
+    = let localPoint  = toBoardLocal (fromIntegral <$> globalPoint) bbox
+          maybeCoords = findPositionWithPiece (board gameState)
+                                              boardView
+                                              localPoint
+                                              (currentPlayer gameState)
+          newBoardView coords = boardView { coordsInMotion = Just coords }
+      in  if isGameOver gameState
+              then model
+              else case maybeCoords of
+                  Nothing     -> model
+                  Just coords -> model { boardView = newBoardView coords }
+
+dropPiece :: Model -> V2 Int -> Model
+dropPiece model@Model { boardView = boardView@BoardView { bbox, orient, coordsInMotion = Just dragCoords }, gameState } globalPoint
+    = let
+          localPoint    = toBoardLocal (fromIntegral <$> globalPoint) bbox
+          maybeToCoords = pointToCoords bbox localPoint orient
+          maybeTargetCoordMove =
+              (\to -> printMove dragCoords to Nothing) <$> maybeToCoords
+          maybeNextState = maybeTargetCoordMove >>= move gameState
+          wasToSameSquare = dragCoords `elem` maybeToCoords
+          pc = fromJust $ pieceAt (board gameState) $ printCoordinate
+              dragCoords
+          stopDragModel =
+              model { boardView = boardView { coordsInMotion = Nothing } }
+          promotionModel = stopDragModel
+              { playerState = PromotionPrompt dragCoords
+                                              (fromJust maybeToCoords)
+              }
+          illegalMoveModel = stopDragModel
+              { lastMoveAttempt = Illegal pc dragCoords maybeToCoords
+              }
+          checkForPromotion targetMove
+              | canPromote gameState targetMove = promotionModel
+              | wasToSameSquare                 = stopDragModel
+              | otherwise                       = illegalMoveModel
+      in
+          case maybeNextState of
+              Just nextGameState ->
+                  endTurn stopDragModel { gameState = nextGameState }
+              Nothing ->
+                  maybe stopDragModel checkForPromotion maybeTargetCoordMove
+dropPiece model _ = model -- Nothing in motion
+
diff --git a/src/Model.hs b/src/Model.hs
index 6475ece..45b007c 100644
--- a/src/Model.hs
+++ b/src/Model.hs
@@ -4,109 +4,51 @@ module Model where
 
 import           Chess
 import           Data.Maybe                     ( fromJust )
-import           Linear.V2                      ( V2 )
 
-import           BoardView
 import           ChessUtils
 import           Options
 
 data Model = Model
     { gameState :: !GameState
     , playerState :: !PlayerState
-    , options :: !Options
-    , windowDims :: !(V2 Int)
-    , mousePos :: !(V2 Int)
-    , boardView :: !BoardView
     , lastMoveAttempt :: !MoveAttempt
+    , coordsInMotion :: !(Maybe Coordinates)
     }
     deriving (Show)
 
-initialModel :: Options -> V2 Int -> Model
-initialModel options windowDims = Model
+data PlayerState =
+    Playing |
+    HotSeatWait |
+    HotSeatBlank |
+    PromotionPrompt Coordinates Coordinates
+    deriving (Show, Eq)
+
+initialModel :: Model
+initialModel = Model
     { gameState       = newGame
     , playerState     = Playing
-    , options
-    , windowDims
-    , mousePos        = pure 0
-    , boardView       = initialBoardView windowDims
     , lastMoveAttempt = Successful
+    , coordsInMotion = Nothing
     }
 
-resize :: Model -> V2 Int -> Model
-resize model@Model { boardView } windowDims =
-    let bbox = calcBoardBBox windowDims
-    in  model { windowDims, boardView = boardView { bbox } }
-
-rotateBoard :: Model -> Model
-rotateBoard model@Model { boardView = boardView@BoardView { orient = Black } }
-    = model { boardView = boardView { orient = White } }
-rotateBoard model@Model { boardView = boardView@BoardView { orient = White } }
-    = model { boardView = boardView { orient = Black } }
-
-startDragPiece :: Model -> V2 Int -> Model
-startDragPiece model@Model { boardView = boardView@BoardView { bbox }, gameState } globalPoint
-    = let localPoint  = toBoardLocal (fromIntegral <$> globalPoint) bbox
-          maybeCoords = findPositionWithPiece (board gameState)
-                                              boardView
-                                              localPoint
-                                              (currentPlayer gameState)
-          newBoardView coords = boardView { coordsInMotion = Just coords }
-      in  if isGameOver gameState
-              then model
-              else case maybeCoords of
-                  Nothing     -> model
-                  Just coords -> model { boardView = newBoardView coords }
-
-dropPiece :: Model -> V2 Int -> Model
-dropPiece model@Model { boardView = boardView@BoardView { bbox, orient, coordsInMotion = Just dragCoords }, gameState } globalPoint
-    = let
-          localPoint    = toBoardLocal (fromIntegral <$> globalPoint) bbox
-          maybeToCoords = pointToCoords bbox localPoint orient
-          maybeTargetCoordMove =
-              (\to -> printMove dragCoords to Nothing) <$> maybeToCoords
-          maybeNextState = maybeTargetCoordMove >>= move gameState
-          wasToSameSquare = dragCoords `elem` maybeToCoords
-          pc = fromJust $ pieceAt (board gameState) $ printCoordinate
-              dragCoords
-          stopDragModel =
-              model { boardView = boardView { coordsInMotion = Nothing } }
-          promotionModel = stopDragModel
-              { playerState = PromotionPrompt dragCoords
-                                              (fromJust maybeToCoords)
-              }
-          illegalMoveModel = stopDragModel
-              { lastMoveAttempt = Illegal pc dragCoords maybeToCoords
-              }
-          checkForPromotion targetMove
-              | canPromote gameState targetMove = promotionModel
-              | wasToSameSquare                 = stopDragModel
-              | otherwise                       = illegalMoveModel
-      in
-          case maybeNextState of
-              Just nextGameState ->
-                  endTurn stopDragModel { gameState = nextGameState }
-              Nothing ->
-                  maybe stopDragModel checkForPromotion maybeTargetCoordMove
-dropPiece model _ = model -- Nothing in motion
-
-promote :: Model -> PieceType -> Model
-promote model@Model { gameState, playerState = PromotionPrompt fromPos toPos } pieceType
+promote :: Options -> Model -> PieceType -> Model
+promote options model@Model { gameState, playerState = PromotionPrompt fromPos toPos } pieceType
     = let coordMove    = printMove fromPos toPos $ Just pieceType
-          newGameState = fromJust $ move gameState coordMove -- state machine guarantees a Just
-      in  endTurn $ model { gameState = newGameState }
-promote model _ = model -- cannot promote in other player states
+          newGameState = fromJust $ move gameState coordMove -- legal move already verified
+      in  endTurnModel options $ model {gameState = newGameState} -- TODO make sure view also ends turn -- the end of turn should be coordinated by controller
+promote _ model _ = model -- cannot promote in other player states
 
 canPromote :: GameState -> String -> Bool
 canPromote gameState coordMove = isLegalMove gameState (coordMove ++ "=Q")
 
-endTurn :: Model -> Model
-endTurn model@Model { options = Options { gameVariant, hotSeat }, boardView = boardView@BoardView { orient } }
-    = let gameState'                    = gameState model
-          (nextPlayerState, nextOrient) = case (gameVariant, hotSeat) of
-              (Kriegspiel, True) -> (HotSeatWait, currentPlayer gameState')
-              (Chess     , True) -> (Playing, currentPlayer gameState')
-              _                  -> (Playing, orient)
-      in  model { playerState     = nextPlayerState
-                , boardView       = boardView { orient = nextOrient }
-                , lastMoveAttempt = Successful
-                }
+endTurnModel :: Options -> Model -> Model
+endTurnModel Options{hotSeat, gameVariant} model =
+  let
+    gameState'                    = gameState model
+    playerState' = case (hotSeat, gameVariant) of
+        (True, Kriegspiel) -> HotSeatWait
+        _                  -> Playing
+  in 
+    model { playerState     = playerState'
+          , lastMoveAttempt = Successful
+          }
\ No newline at end of file
diff --git a/src/View.hs b/src/View.hs
new file mode 100644
index 0000000..5882dd2
--- /dev/null
+++ b/src/View.hs
@@ -0,0 +1,343 @@
+{-# LANGUAGE NamedFieldPuns #-}
+
+module View where
+
+import           Chess
+import           Control.Applicative            ( pure )
+import           Control.Monad                  ( guard )
+import           Data.Array                    as A
+import           Data.Char                      ( ord
+                                                , chr
+                                                , toLower
+                                                )
+import           Data.List                      ( map
+                                                , sortOn
+                                                , foldl'
+                                                )
+import qualified Data.Map.Strict               as M
+import           Data.Maybe                     ( isJust
+                                                , fromJust
+                                                )
+import           Data.Maybe.HT                  ( toMaybe )
+import           Helm
+import qualified Helm.Color                    as HelmColor
+import           Helm.Engine                    ( Engine )
+import           Helm.Engine.SDL                ( SDLEngine )
+import qualified Helm.Graphics2D               as HGfx
+import           Helm.Graphics2D.Text
+import           Linear.V2                      ( V2(V2) )
+
+import           ChessUtils
+import           Model
+import           Options
+
+-- for this game a bounding box is always square
+data BoundingSquare = BSquare
+    { width :: !Double
+    , topLeft :: !(V2 Double)
+    } deriving (Show)
+
+data View = View
+    { windowDims :: !(V2 Int)
+    , bbox :: !BoundingSquare
+    , orient :: !Color
+    , pointerPos :: !(V2 Int)
+    }
+    deriving (Show)
+
+initialWindowDims :: V2 Int
+initialWindowDims = V2 1000 640
+
+border :: Num a => V2 a
+border = V2 100 100
+
+initialView :: View
+initialView = View
+  { windowDims = initialWindowDims
+  , bbox       = calcBoardBBox initialWindowDims
+  , orient     = White
+  , pointerPos = pure 0
+  }
+
+calcBoardBBox :: (Integral a, Ord a) => V2 a -> BoundingSquare
+calcBoardBBox windowSize =
+  let constrainSquare (V2 x y) = x `min` y
+      calcBoardSize = constrainSquare . subtract (2 * border)
+  in  BSquare
+        { width   = fromIntegral $ calcBoardSize windowSize
+        , topLeft = border
+        }
+
+resizeView :: View -> V2 Int -> View
+resizeView view windowDims =
+    view { windowDims, bbox = calcBoardBBox windowDims }
+
+rotateBoard :: View -> View
+rotateBoard view@View { orient = Black } = view { orient = White }
+rotateBoard view@View { orient = White } = view { orient = Black }
+
+endTurnView :: Options -> Model -> View -> View
+endTurnView Options{hotSeat} model view@View{orient} =
+  let
+    orient' = if hotSeat
+              then currentPlayer $ gameState model
+              else orient
+  in
+    view{orient = orient'}
+
+pointToCoords :: BoundingSquare -> V2 Double -> Color -> Maybe Coordinates
+pointToCoords bbox (V2 x y) playerOrient =
+  let ssize = squareSize bbox
+      tryCoords White = (floor (y / ssize), floor (x / ssize))
+      tryCoords Black = (7 - floor (y / ssize), floor (x / ssize))
+      thisTryCoords = tryCoords playerOrient
+  in  isInsideBoard thisTryCoords `toMaybe` thisTryCoords
+
+toBoardLocal :: V2 Double -> BoundingSquare -> V2 Double
+toBoardLocal globalV2 bbox = globalV2 - topLeft bbox
+
+sideBarTexts
+  :: HelmColor.Color -- ^ the text color
+  -> MoveAttempt
+  -> GameState
+  -> PlayerState
+  -> [Text]
+sideBarTexts helmColor moveAttempt gameState playerState =
+  hotSeatTexts helmColor playerState (currentPlayer gameState)
+    ++ checkText         helmColor gameState
+    ++ moveAttemptText   helmColor moveAttempt
+    ++ promptPromoteText helmColor playerState
+
+hotSeatTexts :: HelmColor.Color -> PlayerState -> Color -> [Text]
+hotSeatTexts helmColor playerState currPlayer =
+  let prompt HotSeatWait =
+        ["Type <Space> to blank screen", "for " ++ show currPlayer]
+      prompt HotSeatBlank =
+        ["Type <Space> to start turn", "for " ++ show currPlayer]
+      prompt _ = []
+  in  height 20 . color helmColor . toText <$> prompt playerState
+
+promptPromoteText :: HelmColor.Color -> PlayerState -> [Text]
+promptPromoteText helmColor playerState =
+  let showPlayerState (PromotionPrompt _ _) =
+        [ "Promote Pawn:"
+        , "Type Q for Queen"
+        , "B for Bishop"
+        , "R for Rook"
+        , "N for Knight"
+        ]
+      showPlayerState _ = []
+  in  height 20 . color helmColor . toText <$> showPlayerState playerState
+
+checkText :: HelmColor.Color -> GameState -> [Text]
+checkText helmColor gameState =
+  let showCheck LongDiagonal  = "Check on long diagonal"
+      showCheck ShortDiagonal = "Check on short diagonal"
+      showCheck KnightCheck   = "Check from a Knight"
+      showCheck ckType        = show ckType ++ " check"
+  in  height 30 . color helmColor . toText . showCheck <$> findChecks gameState
+
+moveAttemptText :: HelmColor.Color -> MoveAttempt -> [Text]
+moveAttemptText helmColor moveAttempt =
+  let showLastMoveAttempt Successful = []
+      showLastMoveAttempt (Illegal (Piece _ pieceType) from (Just to)) =
+        ["Move not legal: ", show pieceType ++ " " ++ printMove from to Nothing]
+      showLastMoveAttempt (Illegal (Piece _ pieceType) from Nothing) =
+        [ "Not Allowed to move"
+        , show pieceType
+        , "  from " ++ printCoordinate from ++ " to off the board"
+        ]
+  in  height 30 . color helmColor . toText <$> showLastMoveAttempt moveAttempt
+
+toMoveText :: HelmColor.Color -> GameState -> Text
+toMoveText helmColor gameState =
+  let currPlayer = currentPlayer gameState
+      showToMove = case maybeGameOver gameState of
+        Nothing       -> " To Move: " ++ show currPlayer
+        Just gameOver -> show gameOver
+  in  height 30 $ color helmColor $ toText showToMove
+
+textOverlay
+  :: HelmColor.Color
+  -> View
+  -> GameState
+  -> MoveAttempt
+  -> PlayerState
+  -> HGfx.Form SDLEngine
+textOverlay helmColor View { bbox = BSquare { width, topLeft = (V2 left top) } } gameState moveAttempt playerState
+  = let
+      topX     = width / 2 + left
+      topY     = top / 2
+      sidebarX = width + left + 175
+      sidebarY = top + 15
+      topForm =
+        HGfx.move (V2 topX topY) $ HGfx.text $ toMoveText helmColor gameState
+
+      sbarTexts = sideBarTexts helmColor moveAttempt gameState playerState
+
+      calcOffsets :: [V2 Double] -> Text -> [V2 Double]
+      calcOffsets offs@(V2 x y : _) txt = V2 x (y + textHeight txt) : offs
+      calcOffsets []                _   = []
+
+      offsets :: [V2 Double]
+      offsets = reverse $ foldl' calcOffsets [pure 0] sbarTexts
+
+      toForm :: V2 Double -> Text -> HGfx.Form SDLEngine
+      toForm offset txt = HGfx.move offset $ HGfx.text txt
+
+      sidebarOffsetForm :: V2 Double -> Text -> HGfx.Form SDLEngine
+      sidebarOffsetForm (V2 x y) = toForm (V2 (sidebarX + x) (sidebarY + y))
+    in
+      case sbarTexts of
+        [] -> topForm
+        [firstTxt] ->
+          HGfx.group [topForm, toForm (V2 sidebarX sidebarY) firstTxt]
+        firstTxt : txts -> HGfx.group
+          ( topForm
+          : toForm (V2 sidebarX sidebarY) firstTxt
+          : (uncurry sidebarOffsetForm <$> zip (tail offsets) txts)
+          )
+
+boardForm
+  :: Engine e => Image e -> Image e -> View -> [Coordinates] -> HGfx.Form e
+boardForm lightSquare darkSquare View { bbox = bbox@BSquare { width }, orient } pawnTries
+  = let ssize     = squareSize bbox
+        imageDims = V2 ssize ssize
+        pawnTryForm =
+          -- TODO attempt to vertically center text form inside group
+          -- doesn't work, bug in Helm?
+          HGfx.move (V2 0 ssize / 2)
+            $ HGfx.text
+            $ height 12
+            $ color (HelmColor.rgb 1 1 1)
+            $ bold
+            $ toText "pawn try"
+        sqTypes = squareTypes pawnTries
+        sqForm Light = HGfx.image imageDims lightSquare
+        sqForm Dark  = HGfx.image imageDims darkSquare
+        buildForm (sqColor, False) = sqForm sqColor
+        buildForm (sqColor, True ) = HGfx.group [sqForm sqColor, pawnTryForm]
+        mkSquareForm coords = buildForm (sqTypes M.! coords)
+        mkRankLabel y =
+          HGfx.text
+            $ height 15
+            $ color (HelmColor.rgb (33 / 255) (118 / 255) $ 199 / 255)
+            $ toText
+            $ show
+            $ if orient == White then 8 - y else y + 1
+        mkFileLabel x =
+          HGfx.text
+            $ height 15
+            $ color (HelmColor.rgb (33 / 255) (118 / 255) $ 199 / 255)
+            $ toText [chr $ ord 'a' + x]
+    in  HGfx.toForm
+        $  HGfx.collage
+        $  [ HGfx.move (V2 hOff vOff) $ mkRankLabel (floor y :: Integer)
+           | y <- [0 .. 7]
+           , let vOff = y * ssize + (ssize / 2)
+           , let hOff = -10
+           ]
+        ++ [ HGfx.move (V2 hOff vOff) $ mkFileLabel $ floor x
+           | x <- [0 .. 7]
+           , let hOff = x * ssize + (ssize / 2)
+           , let vOff = width + 20
+           ]
+        ++ [ HGfx.move offset $ mkSquareForm coords
+           | file <- [0 .. 7]
+           , rank <- [0 .. 7]
+           , let coords = (rank, file)
+           , let offset = toOffset coords orient ssize
+           ]
+
+data SquareColor = Light | Dark
+        deriving (Show, Eq)
+type SquareType = (SquareColor, Bool) -- ^ bool is hasPawnTry
+
+squareTypes
+  :: [Coordinates]                -- ^ pawnTries
+  -> M.Map Coordinates SquareType -- ^ square types
+squareTypes pawnTries = M.fromList
+  [ (coord, squareType)
+  | rank <- [0 .. 7]
+  , file <- [0 .. 7]
+  , let coord       = (rank, file)
+  , let hasPawnTry  = coord `elem` pawnTries
+  , let squareColor = if (rank + file) `mod` 2 == 0 then Light else Dark
+  , let squareType  = (squareColor, hasPawnTry)
+  ]
+
+piecesForm
+  :: Engine e
+  => PlayerState
+  -> GameState
+  -> Options
+  -> Model
+  -> View
+  -> M.Map String (Image e)
+  -> V2 Int
+  -> HGfx.Form e
+piecesForm playerState gameState Options{gameVariant}  Model{coordsInMotion} View{bbox, orient} assets mousePos
+  = let
+      showColor clr = toLower (head $ show clr)
+      showPieceType pieceType = toLower <$> show pieceType
+      pieceName (Piece clr pieceType) =
+        showColor clr : "_" ++ showPieceType pieceType
+      chooseImage piece = assets M.! pieceName piece
+      ssize     = squareSize bbox
+      imageDims = pure ssize
+      mkForm piece = HGfx.image imageDims $ chooseImage piece
+
+      -- sort pieces so moving or promoting piece is on top
+      sortF :: PlayerState -> Coordinates -> Bool
+      sortF (PromotionPrompt _ toCoords) thisCoords =
+        (do
+            p <- coordsInMotion
+            return $ p == thisCoords || toCoords == thisCoords
+          )
+          == Just True
+      sortF _ thisCoords = Just thisCoords == coordsInMotion
+
+      pieceImage coords piece
+        | (PromotionPrompt fromCoords toCoords) <- playerState
+        , coords == fromCoords
+        = HGfx.move (toOffset toCoords orient ssize) $ mkForm piece
+        | coordsInMotion == Just coords
+        = HGfx.move
+            (toBoardLocal (fromIntegral <$> mousePos) bbox - imageDims / 2)
+          $ mkForm piece
+        | otherwise
+        = HGfx.move (toOffset coords orient ssize) $ mkForm piece
+
+      pieces =
+        [ (coords, piece)
+        | (coords, square) <- assocs $ board gameState
+        , let maybePiece = squareToMaybe square
+        , isJust maybePiece
+        , let piece@(Piece clr _) = fromJust maybePiece
+        , case (isGameOver gameState, playerState, gameVariant, clr) of
+          (True, _, _, _) -> True
+          (_, HotSeatBlank, _, _) -> False
+          (_, _, Chess, _) -> True
+          (_, HotSeatWait, Kriegspiel, White) -> currentPlayer gameState == Black
+          (_, HotSeatWait, Kriegspiel, Black) -> currentPlayer gameState == White
+          (_, _, Kriegspiel, _) -> currentPlayer gameState == clr
+        ]
+      sortedPieces = sortOn (sortF playerState . fst) pieces
+      imageCollage = HGfx.collage $ map (uncurry pieceImage) sortedPieces
+    in
+      HGfx.toForm imageCollage
+
+-- Private functions
+
+squareSize :: BoundingSquare -> Double
+squareSize bbox = width bbox / 8
+
+toOffset
+  :: Coordinates
+  -> Color -- ^ orientation of the board
+  -> Double -- ^ square size
+  -> V2 Double
+toOffset (rank, file) White ssize =
+  (fromIntegral <$> V2 file rank) * pure ssize
+toOffset (rank, file) Black ssize =
+  (fromIntegral <$> V2 file (7 - rank)) * pure ssize
